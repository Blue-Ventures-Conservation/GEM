////////////////////////////////////////////////////////////////////////////////
//////////      Google Earth Engine Mangrove Mapping Methodology     ///////////
//////////                     (GEM) Module  3                    ///////////
////////////////////////////////////////////////////////////////////////////////


/* 

This code was developed for Blue Ventures Conservation, by Max Yancho.
Questions about the project and the application of the script(s) should be 
directed to Dr. Trevor Jones, Geospatial & Blue Forests Science Adviser 
(trevor@blueventures.org). Questions about the code can be directed to 
Court Fowler (courtland.fowler@blueventures.org).

Developed on:  3 June 2020
Last updated: 17 July 2024

Throughout this tool you will find references to the user name 'yanchojo'. This 
is Mr. Yancho's (the primary developer) personal Google account. Future 
iterations of the Google Earth Engine Mangrove Mapping Methodology (GEM) tool
will be hosted by a Blue Ventures Conservation Google account.


///////////////////////////////////////////////
//////////////  Before  Running  //////////////
///////////////////////////////////////////////


Welcome to Module 3 of the GEM. This module will be used to: 1.) Explore the 
mangrove (or other land cover class) loss, persistence, and gain dynamics. 2.) Provide a 
tool to conduct a qualitative accuracy assessment (QAA). The QAA is an entirely optional
component of the GEM, however it adds another option for analysing of the land cover maps.
This is the final module of the GEM. Outputs from Module 3 will include three image layers 
which will represent the loss, persistence, and gain for the selected land cover class, as
well as a CSV file containing the user generated QAA feedback.

GEM Module 3 is broken down into 3 sections. 

    Section 1: The first step allows the user to select a land cover class for a dynamics 
               analysis. The class is selected prior to the script being run.

    Section 2: The land cover class dynamics calculated include the area of loss, persistence,
               and gain, align with the historic and contemporary land cover class areas: all
               of which are populated in the ‘Console’ The loss, persistence, and gain will 
               also be added as image layers to the map viewer and export tasks begun for each 
               dynamics' image layer. 
               
    Section 3: The qualitative accuracy assessments (QAA). The QAA is centered around two randomly 
               generated grids. During the QAA process, the user will cycle through random, 
               automatically generated cells and qualitatively asses the land cover map(s) 
               generated in Module 2. The region of interest (ROI) is first divided into a large 
               cell parent grid (set by user), of which 50% are randomly selected for analysis. 
               Then, each parent grid cell is subdivided into sub-grids (scale set by user); of 
               which 20% are retained for analysis. It is within these sub-grid cells that the 
               QAA takes place. For each sub-grid cell, the user can record if each land cover 
               class is over, well, or under represented, and provide written comments for each 
               cell. Tallies for all of the sub-grid cells are recorded along with the comments 
               (recorded with the corresponding cell number), which can be viewed at any time and 
               exported as a CSV document to the user’s Google drive at any time. If the user would  
               like to save the grids and use them again outside of GEM they have the ability to 
               export the two grids as shapefiles to their Google Drive. Further instructions and
               QAA feature explanation will be found with Step 2 of Module 3. 

After pressing the ‘Run’ button at the top of the script editor, the user will be prompted
to select the country in which the ROI is found. (Currently, across-border ROI dynamics 
analysis are not supported). Once the workflow has begun it can take as little as five 
minutes to work through Module 3, however, this is just the time to fully load Module 3 
all the way through the QAA. (Note: the area calculation in the dynamics section does take 
a while to load, be patient as it may temporarily freeze your browser.)The time spent working 
through the QAA may take several minutes or tens of hours depending on the size of the area 
and the detail recorded in the comments.

The default parameters, as discussed in the GEM ReadMe file, were established 
during a pilot study conducted for the country of Myanmar (Burma). Many of 
these parameters may also work for other parts of the world, but the developers 
make no claims about the transferability of default settings to other locations.
For applying the GEM elsewhere, please pay careful attention to the parameters 
and set them according to the local situation and project goals/objectives.  

At the end of the workflow, the user should have started exporting:
    1.) Loss Image 
    2.) Gain Image
    3.) Persistence Image
    4.) Large Cell Parent grid
    5.) Small Cell Sub-grid
    6.) QAA CSV file

Before running Module 3, please read through the comments below to determine 
important user inputs and parameters that will be used in this workflow. Continue until 
you reach the end, where you will be prompted to now ‘Run’ the script.

*** Note: Be sure that the 'Code Editor', 'Console' tab, and the map viewer are
all visible on your screen before proceeding ***

/////////////////////////////////////////////////////////
//////////////   Section 1: User Inputs    //////////////
/////////////////////////////////////////////////////////


This portion of the script requires slightly more input from the user. The user
will be required to add a color palette, the land cover class names, and the 
land cover class values to the script as lists.

As in GEM Module 2, bring in Imagery and Masks exported from Module 1. Name 
as follows:

  Chot_image = HOT contemporary composite (HOT_Img_contemporary); highest observed tide
  Clot_image = LOT contemporary composite (LOT_Img_contemporary); lowest observed tide

  Hhot_image = HOT historic composite (HOT_Img_historic); highest observed tide
  Hlot_image = LOT historic composite (LOT_Img_historic); lowest observed tide

  final_mask = Finalized mask (final_mask)
  
  ROI =  Finalized ROI (ROI), region of interest 

This can be done by selecting the assets from the 'Asset' tab and clicking the 
arrow to import the asset to this script. Once imported, the name can be changed
by clicking the default name, e.g. ‘image’ (see top of the script), and renaming.

The next step is for the user to bring in the classification results and 
determine which data they would like to view in the QAA process. By switching the
boolean 'cont_view' and 'hist_view' on and off ('true' and 'false'), the historic or 
contemporary results are displayed. Please note that only one or the other should
be 'true'/'false' at any given time. 
*/

var cont_view = true;
var hist_view = false;

/*
Additionally, the user must define the historic and contemporary classification
inputs as below:


  cont_class = **The contemporary classification**, exported in Module 2
  hist_class = **The historic classification**, exported in Module 2 


As with the imagery, this can be done by selecting the assets from the 'Asset' 
tab and clicking the arrow to import the asset to this script. Once imported,
the name can be changed by clicking the automatic 'image' name (see top of 
the script) and renaming.

Lastly, the classification reference areas (CRAs) needs to be added to
accurately label the various layers and classification inputs. In addition 
to the CRAs, the numeric land cover class number needs to be provided for 
which ever land cover class will be mapped and exported in the dynamics analysis 
(e.g., Closed Canopy Mangroves = 11). Calculations of change across all classes are
performed and displayed in the console. The 'class_nos' variable allows you to combine
multiple classes to be treated as one in the analysis if, for example, you have several
classes for different types of mangroves, but want to see Loss, Persistence and Gain
for all those classes as a group. The maps and exports will be generated for the class(es)
defined in the 'class_nos' variable. If only one class is defined, the name for that class
is used in the analysis, otherwise the variable 'combined_name' can be changed to give a name
to the combined classes in the output.

The dynamics assesment does not need to be a mangrove class, it can be any of the CRAs land cover classes
represent in both land cover maps.
*/


var class_ref = "users/courtlandfowler/tab_cra_2023_reviewed";
// Landcover labels for the classifier
var class_label_numeric = 'Classvalue';   //<<<------<<<< Numeric Column
var class_label_character = 'Classname';  //<<<------<<<< Text Column
var class_nos = [1];                   // (numeric, land class numbers from 'class_label_numeric')
var combined_name = 'Mangroves';


/*
Define sub-regions within your ROI to calaculate the dynamics for.

The ROI from module 1 is included by default. You can add further sub-regions to the analysis
by uploading your own shapefile as a table asset to GEE, or by drawing shapes on the map and then
adding them to this object in the same format as for the ROI, as shown in the example below:

  var region_geometries = {
    "ROI": ROI,
    "Sub Region 1": sub_region_shape,
  };
  
  Give your region a meaningful name, as the name is used to label the outputs.
*/

var region_geometries = {
  "ROI": ROI,
  // add more regions here like so:
  //    "Another Region": region_variable,
};



/*
Set your QAA Grid Scale

The QAA part of the GEM is built around the qualitative analysis of two sets of
one large and once nested sub-grid in the other. The size of these grid cells needs 
to be set by the user in order to be appropriate for the scale of the project. The 
inputs are in meters (m). The two should be evenly divisable; e.g. 1000 / 100 = 10.

Enter:
  var large_grid_scale = 100000; Larger grid scale size (m)
  var nested_grid_scale = 10000; Nested sub-grid scale size (m)

*/

var large_grid_scale = 30000;
var nested_grid_scale = 3000;


/*

    ****************************************************************************
    **********************         Click 'Run' Now        **********************
    ****************************************************************************

      ** This line marks the end of the user-defined inputs and variables. **
      
      What follows is the bulk of the script for module 3 - below this line the
      user does not need to further change anything. Comments are provided 
      for each section/step below so the user can understand how the script 
      actually works. All further user action occurs in the ‘Console'.
      
      NOTES:
            -The exports' destiations are set to the individual user's Google drive.
            -The names of the exports at this juncture matter mostly to the user,
             so any name changes should be meaningful to the the user. 
            -After running the script, directions will follow in the 'Console' to
             walk the user through Sections 2 & 3 of Module 3.
      
                  *** DO NOT EDIT ANYTHING BELOW THIS LINE ***
*/


















//////////////////////////////////////////////////////
//////////////   Section 2: Dynamics    //////////////
//////////////////////////////////////////////////////
// In this section dynamics for the land cover class selected in Section 1 will 
// be generated. Area for loss, persistence, and gain (LPG), as well as the historic
// and contemporary land cover area will be printed to the console. The LPG will be 
// added directly to the map viewer and LPG images will begin to export in the tasks
// tab.

//
var label = class_label_numeric;
var label2 = class_label_character;




var lc_names = ui.data.ActiveList(ee.FeatureCollection(class_ref).distinct(label).sort(label)
                                  .aggregate_array(label2).getInfo());

var colList = {'purple':'purple', 'red':'red','pink':'pink','orange':'orange',
               'yellow':'yellow', 'darkgreen':'darkgreen', 'green':'limegreen', 'lightgreen':'lightgreen',
               'cyan':'cyan','lightblue':'lightblue','blue':'blue','brown':'saddlebrown', 'lightbrown':'burlywood',
               'black':'black', 'white':'white', 'grey':'grey', 'lightgrey':'lightgrey'};

var colors = ee.List.sequence(0,ee.Number(lc_names.length()).subtract(1),1);

lc_names.forEach(function(x){
  var col_drop = ui.Select({
                              placeholder: ee.String("Select " + x + " Colour").getInfo(),
                              items: Object.keys(colList),
                              onChange: function(key) { colors = colors.set(lc_names.indexOf(x), colList[key])}
                              });
 print(x);
 print(col_drop);
});

// Print instructions
print('Print the index list to review indices selected');
// Print color list button
var button = ui.Button({
  label: 'Print Colour List',
  onClick: function() {
    var lab_colors = ee.FeatureCollection(class_ref).distinct(label).sort(label)
                                  .aggregate_array(label2).zip(ee.List(colors));
    alert('Land Cover Color List\n\n' + 
      ee.String(lab_colors.iterate(function(next, prev) {
        var pair = ee.List(next);
        var label = ee.String(pair.get(0));
        var color = ee.String(pair.get(1));
        return ee.String(prev).cat(label.cat(': ').cat(color).cat('\n'));
      }, ee.String(""))).getInfo()
    );
    }
  });
print(button);


// Country Selection 
print(ui.Label({value:'Module 3: Section 2',
                  style:{fontWeight: 'bold',
                         fontSize: '18px',
                         textAlign: 'center'}
                }));
print('Optional: Select the Country\n(to limit analysis to be within its borders).');
var dataset = ee.FeatureCollection('USDOS/LSIB/2017');
var dataset2 = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');
var name_list = ee.List([]); //set up empty list

// Create a list of the names
for (var i = 1; i < 277; i++){
  var country = dataset.filterMetadata('OBJECTID', 'equals', i).first();
  var nm = country.get('COUNTRY_NA');
  name_list = name_list.add(nm);
}

var countryName = null;
var country_selector = ui.Select({
  items: name_list.getInfo(),
  placeholder: 'Choose Country',
  onChange: function(x){
  countryName = x;
  }
});
print(country_selector);
print('Please Note: Google Earth Engine refers to the'+
      '\ncountry of Myanmar as Burma. The names in the above country'+
      '\nlist do not represent the opinions or ideology of the GEM'+
      '\ndevelopment team or Blue Ventures.'+
      '\n'+
      '\nAdditionally, some names are not listed in alphabetical order'+
      '\nthis too relates to data formatting choices of Earth Engine.');


var dyn_setup_button = ui.Button('Click to Choose Classes for Dynamics');
dyn_setup_button.onClick(function(){

var cont_res = cont_class;
var hist_res = hist_class;

var chot_masked = Chot_image.updateMask(final_mask);
var clot_masked = Clot_image.updateMask(final_mask);
var hhot_masked = Hhot_image.updateMask(final_mask);
var hlot_masked = Hlot_image.updateMask(final_mask);
if (countryName !== null) {
  var c1 = ee.Feature(dataset2.filterMetadata('country_na', 'equals', countryName).first());
  cont_res = cont_res.clip(c1);
  hist_res = hist_res.clip(c1);
  chot_masked = chot_masked.clip(c1);
  clot_masked = clot_masked.clip(c1);
  hhot_masked = hhot_masked.clip(c1);
  hlot_masked = hlot_masked.clip(c1);
}

// Setup for Dynamics, combine classes and choose which other classes to show

var sorted = ee.FeatureCollection(class_ref).distinct(label).sort(label);
var sortedValues = sorted.aggregate_array(label);
var sortedNames = sorted.aggregate_array(label2);
var sorteds = ee.List([sortedValues, sortedNames]).getInfo();
sortedValues = sorteds[0];
sortedNames = sorteds[1];
var class_num = class_nos[0];
var classColors = colors;

if (class_nos.length > 1) {
  var cni = sortedValues.indexOf(class_num);
  sortedNames[cni] = combined_name;
  var cont_combo = cont_res.eq(class_num).multiply(class_num);
  var hist_combo = hist_res.eq(class_num).multiply(class_num);
  var cont_neg = cont_res.neq(class_num);
  var hist_neg = hist_res.neq(class_num);
  
  for (var i = 1; i < class_nos.length; i++) {
    var cn = class_nos[i];
    var idx = sortedValues.indexOf(cn);
    sortedValues.splice(idx, 1);
    sortedNames.splice(idx, 1);
    classColors = classColors.splice(idx, 1);
    cont_combo = cont_combo.add(cont_res.eq(cn).multiply(class_num));
    hist_combo = hist_combo.add(hist_res.eq(cn).multiply(class_num));
    cont_neg = cont_neg.and(cont_res.neq(cn));
    hist_neg = hist_neg.and(hist_res.neq(cn));
  }
  
  // combine 'class_nos' values within classified imagery:
  // first, multiply by the mask to remove combined area
  // then add the combined area back, but all with the same value
  // (the first number in class_nos)
  cont_res = cont_res.multiply(cont_neg).add(cont_combo);
  hist_res = hist_res.multiply(hist_neg).add(hist_combo);
}

var targetClassName = sortedNames[sortedValues.indexOf(class_num)];

print('In addition to ' + targetClassName + ', please select which other classes to analyse:');

var included = {};
sortedNames.forEach(function(sname){
  included[sname] = true;

  if (sname == targetClassName) {
    return;
  }
  
  var clz_box = ui.Checkbox(sname, true);
  clz_box.onChange(function(checked) {
    included[sname] = checked;
  });
  
  print(clz_box);
});

// Create the dynamics button
var dyn_button = ui.Button('Click to View Dynamics');
dyn_button.onClick(function(){

// Training polygons
var t_poly = ee.FeatureCollection(class_ref);

// Extract the LC class names and values and make list
var values = t_poly.distinct(label).aggregate_array(label).getInfo();
var names = t_poly.distinct(label2).aggregate_array(label2);

// Redefine the ROI
var ROI_dis = ROI;

// Define the layers of interest
  // Contemporary
  if(cont_view === true){ 
    var class_res = cont_res;
    }
  if( hist_view === true){ 
    var class_res = hist_res;
    }
    
var vis = {bands: ['B4', 'B5', 'B3'], min: 0, max: 0.27};

Map.addLayer(chot_masked, vis, 'Contemporary High Tide');
Map.addLayer(clot_masked, vis, 'Contemporary Low Tide', false);
Map.addLayer(hhot_masked, vis, 'Historic High Tide', false);
Map.addLayer(hlot_masked, vis, 'Historic Low Tide', false);
Map.centerObject(Chot_image);

function maskArea(mask, geo) {
  var area = ee.Image.pixelArea().updateMask(ee.Image(mask));
  return ee.Number(area.reduceRegion({
    reducer: ee.Reducer.sum(),
    geometry: geo,
    scale: 30,
    maxPixels: 1e13,
    bestEffort: true
  }).get('area')).divide(10).round().divide(1e3);
}

function exportDyn(img, descrip, geo) {
  Export.image.toDrive({
    image: img,
    description: descrip,
    region: geo,
    scale: 30,
    maxPixels:1e13
  });
}

function exportDynamics(key, label, geo, loss, pers, gain) {
  exportDyn(loss, (label + " loss in " + key).split(' ').join('_'), geo);
  exportDyn(pers, (label + " persistence in " + key).split(' ').join('_'), geo);
  exportDyn(gain, (label + " gain in " + key).split(' ').join('_'), geo);
}

function mapDynamics(key, label, loss, pers, gain) {
  Map.addLayer(loss, {palette: 'red'}, label + ' loss in ' + key);
  Map.addLayer(pers, {palette: 'blue'}, label + ' persistence in ' + key);
  Map.addLayer(gain, {palette: 'green'}, label +' gain in ' + key);
}

function conversionChart(label, areas, colors) {
    var chartLabels = ee.List([]);
    var chartVals = ee.List([]);
    for (var i = 0; i < areas.length; i++) {
      var area = areas[i];
      chartLabels = chartLabels.add(area.name);
      chartVals = chartVals.add(area.area);
    }
    
    var pairs = chartLabels.zip(chartVals);
    var triplets = pairs.map(function(pair){
      var i = pairs.indexOf(pair);
      return ee.List(pair).add(colors.get(i));
    });

    triplets = triplets.insert(0, ['Label', 'Hectares', { role: 'style' }]);
    
    print(ui.Chart(triplets.getInfo()).setChartType('ColumnChart')
    .setOptions({
      title: label,
      hAxis: {title: 'Other classes'},
      vAxis: {title: 'Area (ha)'},
      legend: {position: "none"}
    }));
}

function percentChange(hist, cont) {
  return percent((cont - hist), hist);
}

function percent(num, denom) {
  return Math.round(((num/denom) * 1e4))/1e2 + "%";
}

var conversionSelectors = [];

function conversionData(conv, sortedNames) {
  var dat = {};
  var selectors = [];
  
  var fromIndex = 0;
  for (var i in sortedNames) {
    var fromName = sortedNames[i];
    if (!included[fromName]) {
      continue;
    }
    
    var fromKey = "Conversion from " + fromName;
    selectors.push(fromKey);
    
    if (fromIndex >= conv.from.length) {
      dat[fromKey] = null;
      continue;
    }
    
    var from = conv.from[fromIndex];
    if (from.name != fromName) {
      dat[fromKey] = null;
    } else {
      dat[fromKey] = from.area;
      fromIndex++;
    }
  }
  
  var toIndex = 0;
  for (var j in sortedNames) {
    var toName = sortedNames[j];
    if (!included[toName]) {
      continue;
    }
    
    var toKey = "Conversion to " + toName;
    selectors.push(toKey);
    
    if (toIndex >= conv.to.length) {
      dat[toKey] = null;
      continue;
    }
    
    var to = conv.to[toIndex];
    if (to.name != toName) {
      dat[toKey] = null;
    } else {
      dat[toKey] = to.area;
      toIndex++;
    }
  }
  
  conversionSelectors = selectors;
  
  return dat;
}

var dynamicsData = [];

for (var key in region_geometries) {
  var geo = region_geometries[key];
  
  var classImgs = ee.List([]);
  for (var p = 0; p < sortedValues.length; p++) {
    var n = sortedValues[p];
    classImgs = classImgs.add(ee.Dictionary({
      cont: cont_res.eq(n),
      hist: hist_res.eq(n)
    }));
  }
  
  print(
    ui.Label({
      value: 'Dynamics in: ' + key,
      style: {
        fontWeight: 'bold',
        fontSize: '16px',
        textAlign: 'center'
      }
    })
  );
  
  for (var pos = 0; pos < sortedValues.length; pos++) {
    var num = sortedValues[pos];
    var lab = sortedNames[pos];
    if (!included[sortedNames[pos]]) {
      continue;
    }
    
    var cimgs = ee.Dictionary(classImgs.get(pos));
    var contClass = ee.Image(cimgs.get("cont"));
    var histClass = ee.Image(cimgs.get("hist"));
    
    var to = ee.List([]);
    var from = ee.List([]);
    for (var p2 = 0; p2 < sortedValues.length; p2++) {
      if (p2 == pos || !included[sortedNames[p2]]) {
        continue;
      }
      
      var cs = ee.Dictionary(classImgs.get(p2));
      var cc = ee.Image(cs.get("cont"));
      var hc = ee.Image(cs.get("hist"));
      
      var nm = sortedNames[p2];
      
      to = to.add(ee.Dictionary({
        name: nm,
        area: maskArea(contClass.and(hc).selfMask(), geo),
      }));
      from = from.add(ee.Dictionary({
        name: nm,
        area: maskArea(histClass.and(cc).selfMask(), geo),
      }));
    }
    
    var lossMask = histClass.subtract(contClass).eq(1).selfMask();
    var lossArea = ee.Number(maskArea(lossMask, geo));
    var perMask = histClass.and(contClass).selfMask();
    var perArea = ee.Number(maskArea(perMask, geo));
    var gainMask = contClass.subtract(histClass).eq(1).selfMask();
    var gainArea = ee.Number(maskArea(gainMask, geo));
    
    if (class_num == num) {
      mapDynamics(key, lab, lossMask.clip(geo), perMask.clip(geo), gainMask.clip(geo));
      exportDynamics(key, lab, geo, lossMask, perMask, gainMask);
    }
    
    var data = ee.Dictionary({
      Region: key,
      Class: lab,
      Historical: perArea.add(lossArea),
      Contemporary: perArea.add(gainArea),
      Loss: lossArea,
      Persistence: perArea,
      Gain: gainArea,
      conv: {
        to: to,
        from: from,
      }
    }).getInfo();
    
    // the geometry here is just a placeholder, we will export a CSV without it
    var convDat = conversionData(data.conv, sortedNames);
    for (var attrname in convDat) {
      data[attrname] = convDat[attrname];
    }
    dynamicsData.push(ee.Feature(ee.Geometry.Point([0, 0]), data));
    
    print(
      ui.Label({
        value: 'Class ' + num + ':  ' + lab + ':',
        style: {
          fontWeight: 'bold',
          fontSize: '16px',
          textAlign: 'center'
        }
      })
    );
    print("Historical area (ha) of " + lab + ":", data.Historical);
    print("Contemporary area (ha) of " + lab + ":", data.Contemporary);
    print("Percent change in area of " + lab, "from historical to contemporary:", percentChange(data.Historical, data.Contemporary));
    print("Area (ha) of " + lab + " loss: ", data.Loss + " [" + percent(data.Loss, data.Historical) + "]");
    print("Area (ha) of " + lab + " persistence: ", data.Persistence + " [" + percent(data.Persistence, data.Historical) + "]");
    print("Area (ha) of " + lab + " gain: ", data.Gain + " [" + percent(data.Gain, data.Histoircal) + "]");
    
    var chartColors = classColors.splice(pos, 1);
    var convs = data.conv;

    conversionChart('"' + lab + '" conversion to other classes', convs.from, chartColors);
    conversionChart('Other class conversion to "' + lab + '"', convs.to, chartColors);
  }
}

Export.table.toDrive({
  description: 'Dynamics_Table',
  collection: ee.FeatureCollection(dynamicsData),
  selectors: ['Region', 'Class', 'Historical', 'Contemporary', 'Loss', 'Persistence', 'Gain'].concat(conversionSelectors)
});

//////////////////////////////////////////////////////
//////////////   Section 3: QAA    //////////////
//////////////////////////////////////////////////////
// This is the QAA section. The user will be walked through a set of 
// grid cells to judge the 'quality' of the classification(s). The user 
// can add comments, and export their observations at any time. The grid
// cells are also exported for use outside of the GEM.


// Create the QAA button
var QAA_button = ui.Button('Click to Proceed to QAA');
QAA_button.onClick(function(){
print(ui.Label({value:'Module 3: Section 3',
                  style:{fontWeight: 'bold',
                         fontSize: '18px',
                         textAlign: 'center'}
                }));
alert('GEE QAA INTERFACE'+
'\n'+
'\nUse the left map for viewing GE '+
'imagery, the centre\nmap for viewing classification outputs, and the right'+
'\nmap for viewing Landsat Composite imagery'+
'\n'+
'\nWhen adding comments, pressing enter or clicking off from'+
'\nthe text box will save the comment. To review saved comments'+
'\nas well as the currently recorded qualitative analysis'+
'\nclick on the Print Dictionary button.'+
'\n'+
'\nWhen satisfied with the current progress or at the completion '+
'\nof the QAA, the dictionary, along with all of the saved comments,'+
'\ncan be exported to your Google Drive as a CSV file. Click on the '+
'\nExport Dictionary button to initiate this task.');


var vis = {bands: ['B4', 'B5', 'B3'], min: 0, max: 0.27};

// Add three maps to the screen.
var left = ui.Map();
var right = ui.Map();
var centre = ui.Map();
ui.Map.Linker([left,right,centre]);  

// Add maps to the imagery
ui.root.clear();
ui.root.add(left);
ui.root.add(centre);
ui.root.add(right);
left.setOptions("SATELLITE");


// Add the Landsat imagery to the map
right.addLayer(chot_masked, vis, 'Contemporary High Tide');
right.addLayer(clot_masked, vis, 'Contemporary Low Tide', false);
right.addLayer(hhot_masked, vis, 'Historic High Tide', false);
right.addLayer(hlot_masked, vis, 'Historic Low Tide', false);

// ADD ROI
// Add the ROI to the all maps, in red outline with no fill
right.addLayer(ROI_dis, {palette: 'black'}, 'ROI', false);
centre.addLayer(ROI_dis, {palette: 'black'}, 'ROI', false);
left.addLayer(ROI_dis, {palette: 'black'}, 'ROI', false);
left.centerObject(ROI_dis);

// Get the size of the list
var n = ee.List(values).size().getInfo();

// Add classified layers to central map
for (var i = 0; i < n; i++) {
  var val = ee.List(values).get(i).getInfo();
  var exp = class_res.select('classification').eq(val).selfMask();
  var nm = ee.List(names).get(i).getInfo();
  var cl = colors.get(i).getInfo();
  // Adding three mangrove classes - some issues in this code leading to masking errors
  centre.addLayer(exp, {palette: [cl]}, nm, false);
}

function makeGrid(geometry, scale) {
  // Pixel LonLat returns an image with each pixel labeled with longitude and
  // latitude values.
  var lonLat = ee.Image.pixelLonLat();

  // Select the longitude and latitude bands, multiply by a large number then
  // truncate them to integers.
  var lonGrid = lonLat
    .select('longitude')
    .multiply(10000000)
    .toInt();

  var latGrid = lonLat
    .select('latitude')
    .multiply(10000000)
    .toInt();

  // To produce the grid, multiply the latitude and longitude images and then use
  // reduce to vectors at the 10 km resolution to group the grid into vectors.
  return lonGrid
    .multiply(latGrid)
    .reduceToVectors({
      geometry: geometry, // This is undefined until you draw a geometry.
      scale: scale,
      geometryType: 'polygon',
    });
}

// Create larger 100x100 km grid
var grid = makeGrid(ROI.geometry(), large_grid_scale);
var new_grid = grid.randomColumn().filter(ee.Filter.lte('random', 0.5));

// Create the smaller cells
var mini_cells = new_grid.map(function(x){
  var mini_grid = makeGrid(ee.Feature(x).geometry(), nested_grid_scale); 
  mini_grid = mini_grid.randomColumn().filter(ee.Filter.lte('random', 0.20));
  mini_grid = mini_grid.map(function(feat){
    var geom =feat.geometry().coordinates().flatten();
    return ee.Feature(ee.Geometry.LinearRing(geom));
  });
  
  return mini_grid;
});

// Add small cells to the maps
centre.addLayer(ee.FeatureCollection(mini_cells).flatten(), {color:'yellow'}, " AOIs");
right.addLayer(ee.FeatureCollection(mini_cells).flatten(), {color:'yellow'}, " AOIs");
left.addLayer(ee.FeatureCollection(mini_cells).flatten(), {color:'yellow'}, " AOIs");

// Correct the geometry of the original grid so that it looks good to display
new_grid = new_grid.map(function(feat){
    var geom =feat.geometry().coordinates().flatten();
    return ee.Feature(ee.Geometry.LinearRing(geom));
  });
// Add the grid to the maps
centre.addLayer(ee.FeatureCollection(new_grid), {}, 'grid');
right.addLayer(ee.FeatureCollection(new_grid), {}, 'grid');
left.addLayer(ee.FeatureCollection(new_grid), {}, 'grid');

// Use a DateSlider to create annual composites of this collection.
var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1');
// Use the start of the collection and now to bound the slider.
var start = ee.Image(collection.first()).date().get('year').format();
var now = Date.now();
var end = ee.Date(now).format();

// Run this function on a change of the dateSlider.
var showMosaic = function(range) {
  var mosaic = ee.Algorithms.Landsat.simpleComposite({
    collection: collection.filterDate(range.start(), range.end())
  });
  // Asynchronously compute the name of the composite.  Display it.
  range.start().get('year').evaluate(function(name) {
    var visParams = {bands: ['B4', 'B3', 'B2'], max: 100};
    var layer = ui.Map.Layer(mosaic, visParams, name + ' composite');
    left.layers().set(0, layer);
  });
};

// Asynchronously compute the date range and show the slider.
var dateRange = ee.DateRange(start, end).evaluate(function(range) {
  var dateSlider = ui.DateSlider({
    start: range['dates'][0],
    end: range['dates'][1],
    value: null,
    period: 365,
    onChange: showMosaic,
    style: {
      position: 'bottom-right'
    }
  });
  left.add(dateSlider.setValue(now));
});

// Create and Print title
var title = ui.Label('GEE QAA INTERFACE');
title.style().set('fontWeight', 'bold');
title.style().set({
    fontSize: '20px',
    padding: '5px'
    });
print(title);

// Print instructions to the console
var instructions = ui.Label('Use the left map for viewing GE '+
'imagery, the centre\nmap for viewing classification outputs, and the right'+
'\nmap for viewing Landsat Composite imagery'+
'\n'+
'\nWhen adding comments, pressing enter or clicking off from'+
'\nthe text box will save the comment. To review saved comments'+
'\nas well as the currently recorded qualitative analysis'+
'\nclick on the Print Dictionary button.'+
'\n'+
'\nWhen satisfied with the current progress or at the completion '+
'\nof the QAA, the dictionary, along with all of the saved comments,'+
'\ncan be exported to your Google Drive as a CSV file. Click on the '+
'\nExport Dictionary button to initiate this task.');
instructions.style().set('fontWeight', 'bold');
print(instructions);

// Create Panels
var under_panel = ui.Panel({
  layout: ui.Panel.Layout.flow('vertical'),
  style: {width: '200px'}
});
var well_panel = ui.Panel({
  layout: ui.Panel.Layout.flow('vertical'),
  style: {width: '200px'}
});
var over_panel = ui.Panel({
  layout: ui.Panel.Layout.flow('vertical'),
  style: {width: '200px'}
});

// Create labels
under_panel.add(ui.Label('Under Represented',
                         {fontWeight: 'bold'}));
well_panel.add(ui.Label('Well Represented',
                         {fontWeight: 'bold'}));
over_panel.add(ui.Label('Over Represented',
                         {fontWeight: 'bold'}));

// Create empty list of '0's to fill in by user clicks
var under = ee.List.repeat(0, names.length());
var well = ee.List.repeat(0, names.length());
var over = ee.List.repeat(0, names.length());
// Create a list with the postion for each name
var v = ee.List.sequence(0, names.length().subtract(1));

// Create an active list that combines the names and position information 
var l2 = names.zip(v);
l2 = ui.data.ActiveList(l2.getInfo());

// Create buttons for under list
l2.forEach(function(x){
  var lab = ee.List(x).get(0).getInfo(); // Get the label
  var spot = ee.List(x).get(1).getInfo(); // Get the position
  var but = ui.Button({label: lab, onClick: function(){ // Create the button for each name
    under = under.set(spot, ee.Number(ee.List(under).getNumber(ee.List(x).get(1).getInfo()).add(1)));
  }
  });
  under_panel.add(but); // Add to the panel
});
// Create buttons for well list
l2.forEach(function(x){
  var lab = ee.List(x).get(0).getInfo(); // Get the label
  var spot = ee.List(x).get(1).getInfo(); // Get the position
  var but = ui.Button({label: lab, onClick: function(){ // Create the button for each name
    well = well.set(spot, ee.Number(ee.List(well).getNumber(ee.List(x).get(1).getInfo()).add(1)));
  }
  });
  well_panel.add(but); // Add to the panel
});
// Create buttons for over list
l2.forEach(function(x){
  var lab = ee.List(x).get(0).getInfo(); // Get the label
  var spot = ee.List(x).get(1).getInfo(); // Get the position
  var but = ui.Button({label: lab, onClick: function(){ // Create the button for each name
    over = over.set(spot, ee.Number(ee.List(over).getNumber(ee.List(x).get(1).getInfo()).add(1)));
  }
  });
  over_panel.add(but); // Add to the panel
});

// Create list print buttons
var print_un = ui.Button({label: 'Print Under Rep. List', onClick: function(){
  var l3 = names.zip(under);
  print('Under Represented', l3);}});
under_panel.add(print_un);
var print_we = ui.Button({label: 'Print Well Rep. List', onClick: function(){
  var l3 = names.zip(well);
  print('Well Represented', l3);}});
well_panel.add(print_we);
var print_ov = ui.Button({label: 'Print Over Rep. List', onClick: function(){
  var l3 = names.zip(over);
  print('Over Represented', l3);}});
over_panel.add(print_ov);

// Create list reset buttons
var reset_un = ui.Button({label: 'Reset Under Rep. List', onClick: function(){
  under = ee.List.repeat(0, names.length());
  print('Under Represented List Reset');}});
under_panel.add(reset_un);
var reset_we = ui.Button({label: 'Reset Well Rep. List', onClick: function(){
  well = ee.List.repeat(0, names.length());
  print('Well Represented List Reset');}});
well_panel.add(reset_we);
var reset_ov = ui.Button({label: 'Reset Over Rep. List', onClick: function(){
  over = ee.List.repeat(0, names.length());
  print('Over Represented List Reset');}});
over_panel.add(reset_ov);

ui.root.add(under_panel);
ui.root.add(well_panel);
ui.root.add(over_panel);

var mini_poly = mini_cells.flatten().map(function(feat){
      return feat.set({'id': feat.id()});
});

var n2 = ee.Number(0);

var cycle_button = ui.Button({label:'Next Cell', onClick: function(){
  n2 = ee.Number(n2).add(1);
  var name = ee.String('Cell ' + ee.Number.parse(n2).getInfo()).getInfo();
  print(name);
  var cell = ee.Feature(mini_poly.first()).getInfo();
  centre.addLayer(ee.Feature(cell), {color:'red'}, name);
  left.addLayer(ee.Feature(cell), {color:'red'}, name);
  right.addLayer(ee.Feature(cell), {color:'red'}, name);
  centre.centerObject(ee.Feature(cell));
  mini_poly = mini_poly.filter(ee.Filter.neq('id', ee.Feature(mini_poly.first()).id()));
  
}});
print(cycle_button);

var combo_button = ui.Button({label: 'Print Dictionary', onClick: function(){
var dict = ee.Dictionary({
  names: names,
  under_rep: under,
  well_rep: well,
  over_rep: over,
  comments: comments
});
print(dict);
}});
print(combo_button);

var export_button = ui.Button({label: 'Export Dictionary', onClick: function(){
var dict = ee.Dictionary({
  names: names,
  under_rep: under,
  well_rep: well,
  over_rep: over,
  comments: comments
});
var feat = ee.Feature(null, dict);
Export.table.toDrive({collection:ee.FeatureCollection(feat),
                      description: 'GEM_QAA_Dictionary'});
}});
print(export_button);

var comments = ee.List([]);

var comment_button = ui.Button({label: 'Add Comment', onClick: function(){
  print('Comments on Cell ' + ee.Number.parse(n2).getInfo());
  var text = ui.Textbox({
    placeholder: 'Comments on cell condition',
    onChange: function(text){
      var x = ee.String('Cell ' + ee.Number.parse(n2).getInfo() + ": " + text);
      comments = comments.add(x);
    }
  });
  print(text);
}});
print(comment_button);

Export.table.toDrive({collection:new_grid,
                      description: 'Large Cell Parent grid'
  });
Export.table.toDrive({collection:mini_cells,
                      description: 'Small Cell Sub-grid'
  });
});

print(QAA_button);
});
print(dyn_button);
});
print(dyn_setup_button);

// At the end of the workflow, the user should have started exporting:
//    1.) Loss Image 
//    2.) Gain Image
//    3.) Persistence Image
//    4.) Large Cell Parent grid
//    5.) Small Cell Sub-grid
//    6.) QAA CSV file

////////////////////////////////////////////////////////////////////////////////
