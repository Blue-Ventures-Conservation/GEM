////////////////////////////////////////////////////////////////////////////////
//////////      Google Earth Engine Mangrove Mapping Methodology     ///////////
//////////                     (GEM) Module  1                    ///////////
////////////////////////////////////////////////////////////////////////////////

/*

This code was developed for Blue Ventures Conservation, by Max Yancho.
Questions about the project and the application of the script(s) should be 
directed to the GEM Team (gem@blueventures.org).
Questions about the code can be directed to 
Mr. Court Fowler (courtland.fowler@blueventures.org).

Developed on:  3 June 2020
Last updated: 9 December 2024

Throughout this tool you will find references to the user name 'yanchojo'. This 
is Mr. Yancho's (the primary developer) personal Google account. Future 
iterations of the Google Earth Engine Mangrove Mapping Methodology (GEM)
will be hosted by a Blue Ventures Conservation Google account.




///////////////////////////////////////////////
//////////////  Before  Running  //////////////
///////////////////////////////////////////////


Welcome to Module 1 of the GEM. This module is used to: 1.) Identify 
the precise region of interest (ROI) used in the GEM, 2.) generate Landsat or Sentinel-2
image composites, 3.) calculate any desired spectral indices for the generated 
composites and 4.) create a unified mask to remove water pixels or pixels 
associated with extreme topography from classification. This module outputs up to
four image composites (depending on user preference: high- and  low-tide for 
both a historical and contemporary temporal window), a final mask, representing 
unified water, slope, and elevation, and a vector  polygon encompassing the region 
of interest (ROI) to use throughout the GEM workflow. 

GEM Module 1 is broken down into 5 Sections: 

    Section 1: User inputs
    
      Step 1: User identifies the desired data inputs
      Step 2: User identifies the variables to use in module 1, (e.g. dates, 
          thresholds, indices, etc.)

    Section 2: Lets the user interactively explore how large of an region of interest 
               they would like to use by examining known mangrove extent data. 

    Section 3: Generates the selected historical and contemporary Landsat/S2 composites 
               and allows the user to review them in the map viewer. 

    Section 4: Uses the Landsat/S2 composites and the index list from Section 1, Step 2
               to calculate any selected spectral indices.

    Section 5: Creates the composite masks, removing water (if desired) and areas beyond 
               the topographic (i.e., elevation and slope) thresholds. The user has the 
               option to view a combined water and topography mask, or view each mask 
               separately. It is in Section 5 that the mask and ROI may be modified to 
               search for fringe mangroves if user selects that option.

After pressing the ‘Run’ button at the top of the  script editor, a grey button will 
populate in the ‘Console’ to “Begin Workflow”. Shift your attention to the ‘Console’, 
where buttons (starting with ‘Begin Workflow’) provide interactive control as the module
runs.  If you encounter errors, use “find” to find the variables related to the error 
messages. Make corrections in user-defined data or variables as needed, and press ‘Run’ 
again. Once the  workflow has begun it can take as little as three minutes to work 
through Module 1, not accounting for exporting times of the outputs. Times may vary 
depending on internet speed.

The default parameters, as discussed in the GEM ReadMe file, were established 
during a pilot study conducted for the country of Myanmar (Burma). Many of 
these parameters may also work for other parts of the world, but the developers 
make no claims about the transferability of default settings to other locations.
For applying the GEM elsewhere, please pay careful attention to the parameters 
and set them according to the local situation and project goals/objectives.  

At the end of the workflow, the user should have started exporting:
      1) HOT contemporary composite (HOT_Img_contemporary)
      2) LOT contemporary composite (LOT_Img_contemporary)
      3) HOT historical composite (HOT_Img_historical)
      4) LOT historical composite (LOT_Img_historical)
      5) Finalized ROI (ROI) 
      6) Finalized mask (final_mask)

Before running Module 1, please read through the comments below to determine 
important user inputs and parameters that will be used in this workflow. Continue until 
you reach the end, where you will be code-comment prompted to ‘Run’ the script at the end 
of entering the user inputs (Section 1). Do not change variable names, and, if external
data is used, be sure to upload into the user's 'Assets'.


*** Note: Be sure that the 'Code Editor', 'Console' tab, and the map viewer are
all visible on your screen before proceeding ***

////////////////////////////////////////////////////////////
/////////    Section 1, Step 1: User Data Inputs  //////////
////////////////////////////////////////////////////////////


1) USER DEFINED DATA SETS
     In this first section the user must determine what data they would 
     like to use within the Google Earth Engine Mangrove Mapping Methodology 
     (GEM). For each, two options are usually presented: use GEE data or 
     upload external user-selected data. Additionally, if the user would like, 
     they may file a request to Google to add a specific data set into the 
     'Earth Engine Data Catalog'. To submit a data request follow the below 
     link:
     
          https://developers.google.com/earth-engine/help#dataset_requests
          Note: This will likely not be a very quick service/response.   

1.A) Set Preliminary ROI
     The user must first coarsely define their region of interest (ROI). To 
     do so, please use the drawing tools located in the upper left corner of
     the 'Map' to roughly define the part of the world to further investigate.
     The current methodology only supports the use of the ‘Draw a shape’ or 
     ‘Draw a rectangle’ drawing tools at this time. Note: this is not going to 
     be the ROI used in the data processing, this coarse ROI is to simply help 
     select the target data. The geometry that you create must be renamed to 
     "coarse_roi"; this can be done by clicking the newly drawn geometry
     in the script's 'Imports' (located at the top of the script).

1.B) Set Exclusion Areas

     Define areas within your ROI to exclude from imagery and subsequent analysis.

     You can add areas to be excluded from the analysis (for example: dams and their pools/lakes/reservoirs) 
     by uploading your own shapefile as a table asset to GEE, or by drawing shapes on the map and then
     adding them to this object in the same format as for the 'exclude_geo', as shown in the example below:
     
          var exclusion_geometries = [
            exclude_geo,
          ];
*/

var exclusion_geometries = [
  // add geometries to exclude here, like so:
  // exclude_geo,
];

/*
1.C) Force usage of Landsat. It may be that you don't have any interest in using Sentinel-2,
     or that the composites generated by the much higher resolution Sentinel-2 imagery are simply
     too large (their size can exceed 450MB).
    
     Change the value of the parameter below to 'true' to tell the GEM to only use Landsat imagery.
*/

var force_landsat = false;

/*
1.D) Known Mangrove Extent
     The currently known mangrove extent for the study area will play a key role
     in the further identification of methodological variables (such as slope 
     and elevation thresholds). At this time, the user must identify whether GEEEMMM 
     will use the GEE provided Global Mangrove Forests Distribution, v1 (2000), or 
     an alternative ‘known mangrove’ asset which has been uploaded to the user’s 
     account. If the user uses an uploaded dataset they will be prompted to 
     reference the asset path once the workflow begins; after 'Running' the script.
     
     To upload an asset follow the instructions found here:
          https://developers.google.com/earth-engine/guides/asset_manager
     
     Enter:
          var kmx = null; (to use the GEE Global Mangrove Forests Distribution)
          var kmx = "path/to/your/asset"; (to map to the user's 'known mangrove extent' raster asset)
*/

var kmx = null;

/*

1.E) Coastline Data
     The coastline is a very important data set for this workflow. It will be 
     used to define the finalized ROI, as well as to aid in the determination of the
     tidal conditions for each of the Landsat/S2 images which are to be processed. 
     The coastline layer available in GEE is the Large Scale International 
     Boundary Polygons. Alternatively, as per the known mangrove extent, the user 
     may upload their own data as an asset and bring it into the workflow by 
     copying in the asset path into the 'cst_path' variable below.
     
     Enter:
          var cst = true; (the GEE Large Scale International Boundary Polygons)
          var cst = false; (to map to the user's uploaded 'coastline' asset)
                            ^--- Must enter an asset path
*/

var cst = true; 
var cst_path = 'users/yanchojo/gadm36_mmr_0_shore';

/*
1.F) Topographic Data 
     Another important variable is that of the topographic data. The topographic 
     data will be used to set elevation and slope thresholds before the 
     classification is executed. The default GEM topographic data is from the
     JAXA-ALOS satellite radar DSM (30 m). As is the case with the other important
     data inputs, the user has the choice to upload their own data by filling in 
     the 'topo_path' variable below.
     
     Enter:
          var topo = true; (to use the GEE JAXA-ALOS satellite radar DSM (30 m))
          var topo = false; (to map to the user's uploaded 'topographic' asset)
                              ^--- Must enter an asset path
*/

var topo = true;
var topo_path = 'users/yanchojo/topo';

/*
1.G) Optional Inclusion of Error-Prone Landsat 7 Data
     The majority of the Landsat 7 collections have been affected by the Scan Line 
     Corrector (SLC) failure on May 31, 2003. This causes missing data values for 
     about 22% of each scene. While the remaining pixels provide high-quality data,
     the missing data values can potentially create artifacts in the output Landsat
     composites.
     
     The GEM uses Landsat 7 data from before the failure automatically, this flag
     only changes whether data after the failure is included.
     
     To include or exclude the Landsat 7 later than May 31, 2003, toggle
     the variable 'ls_7_in'; between 'true' (to include) and 'false' (to exclude).
     
     Enter:
          var ls_7_in = true; (to include the error-prone Landsat 7 data)
          var ls_7_in = false; (to exclude the error-prone Landsat 7 data)
*/
var ls_7_in = false;


////////////////////////////////////////////////////////////
////////      Section 1, Step 2: User Variables     ////////
////////////////////////////////////////////////////////////


/*
2) USER DEFINED VARIABLES
    In this sub-section, the user will have to define some variables about how 
    the GEM will run. These variables include the historical and contemporary year
    windows, topographic thresholds, cloud cover limits, etc. Each variable will
    be described thoroughly, and helpful resources provided for further insight.


2.A) Contemporary Years
     Define the contemporary year window. These years will bookend the data 
     selected. The years selected are completely up to the user's discretion. Be 
     sure that the two dates are entered in the correct order. See example 
     below. Note: If a single year is desired, put the same year for both 
     variables.
     
     If the start year is 2019 or later for both contemporary and historical years,
     GEM defaults to producing Sentinel-2 composites. Otherwise Landsat is the default.
     
     When using Sentinel-2 imagery, you may prefer to set the start and end
     years to be the same to reduce the number of imagery. This may help
     if you are seeing Too May Concurrent Agreggations errors.
     
     Enter:
          var contemporary_start_year = 2014; (Older Contemporary year)
          var Contemporary_end_year = 2018; (More recent Contemporary year)
*/

var contemporary_start_year = 2024;
var contemporary_end_year = 2024;

/*
2.B) Historical Years
     Define the historical year window. These years will bookend the data 
     selected. The years selected are completely up to the user's discretion. Be 
     sure that the two dates are entered in the correct order. See example below.
     Note: If a single year is desired, put the same year for both variables.
    
     If the start year is 2019 or later for both contemporary and historical years,
     GEM defaults to producing Sentinel-2 composites. Otherwise Landsat is the default.
     
     When using Sentinel-2 imagery, you may prefer to set the start and end
     years to be the same to reduce the number of imagery. This may help
     if you are seeing Too May Concurrent Agreggations errors.
  
     Enter:
          var historical_start_year = 2012; (Older Historical year)
          var historical_end_year = 2014; (More recent Historical year)
*/

var historical_start_year = 2020;
var historical_end_year = 2020;

/*
2.C) Cloud Cover limit  
     The cloud cover limit is a whole number percentage that will be used to 
     filter the Landsat image collection. The cloud cover limit will filter the
     metadata of each image, using the USGS calculated  cloud cover in the Tier
     1 products. 
     (https://www.usgs.gov/core-science-systems/nli/landsat/cfmask-algorithm)
    
     Enter:
          var cloud_cover = 10; (%, 0-100, Integer)

*/

var cloud_cover = 15;

/*
2.D) Cloud Mask - Landsat Only
     There are two options available to mask out clouds for Landsat. There is a mild cloud
     masking option where the clouds are removed using the USGS/NASA bit (Landsat)
     classification quality band and a mild spectral erosion to remove cloud artefacts.
     There is also an aggressive cloud masking option. For Landsat, this method removes
     pixels based on how 'white' they are in the visible spectrum bands. The thermal band
     also plays a role in removing residual clouds. These identified clouds are also
     spectrally eroded.
     
     For Sentinel-2, cloud masking is always CloudScore+ (cs_pdf >= 0.85), regardless of the value set here.
     
     Enter Below:
        var cloud_mask = 'mild';        (To apply a mild cloud mask)
        var cloud_mask = 'aggressive';  (To apply an aggressive cloud mask)

*/

var cloud_mask = 'mild';

/*
2.E) Tidal Zone  
     The tidal zone is a user-defined parameter that is used to help the GEM 
     determine the tidal condition for each image, in both the historical and the
     contemporary image sets. The tidal zone is functionally a shoreline buffer
     which extends seawards from the shore. This distance should be the tidally 
     'active' zone, which will contain the majority of the tidal flats and tidal
     islands which would be exposed and then resubmerged given the tidal state.
     
     The default number is 1000 m (1 km). This number can be tailored for the
     specific region of interest. **NOTE: The tidal zone is NOT the ROI. The
     tidal zone is strictly a seaward buffer and produces no meaningful 
     intermediary data products.**
    
     Enter:
          var tidal_zone = 1000; (meters, Integer)

*/

var tidal_zone = 1000;

/*
2.F) MNDWI Minimum Average
    When calculating the MNDWI that determines the high and low tide imagery,
    the GEM allows users to specify a minimum average value for the MNDWI
    required for an image to be used when determining the water mask.
    
    There is an ongoing issue with atmospheric haze that can affect images,
    artificially raising the SWIR band value for pixels over the ocean.
    
    This can cause pixels over the ocean to appear as land, when the SWIR value
    is high enough. Because we already mask out all the land within the ROI,
    and are fairly confident that the average value of the MNDWI across any
    land-masked image should lean more heavily toward water, we can cut off the
    extremely low average values for MNDWI on images that are affected by
    atmospheric haze. A value of -1 implies that no images will be filtered out
    in this way. Increasing the value will more aggressively filter out images
    that have low MNDWI values.
   
    In some cases, when viewing the water mask at the end of module 1, you may
    notice large amounts of land within your ROI that should be ocean. Try
    increasing this parameter in that case, up to a max of approximately 0.75.
    Much of the time, you shouldn't need to touch this parameter, even if
    you have land showing in the ocean in your water mask. As long as that
    land is outside your ROI, it won't affect the subsequent analysis.
   
    Enter:
        var min_avg = -1; (MNDWI filter value)
*/

var min_avg = 0.5;

/*
2.G) Water Mask
     The GEM offers the option to mask out water pixels using the modified 
     normalized difference water index (MNDWI). The MNDWI is calculated for the 
     entire ROI and water pixels are removed based on a threshold established 
     in the original paper by Dr. H. Xu (2006). If water pixels are not masked, 
     the classification references areas (CRAs) must take this into account in some 
     fashion (e.g., the user must define a “water” class in their CRAs).

     Enter:
          var remove_water = true; (mask out the water pixels using MNDWI)
          var remove_water = false; (water pixels will NOT be masked)
    
    If the water pixels are to be masked, the user has the option to either mask
    pixels which are water in both the historical and contemporary imagery, or to
    just mask pixels that were identified as water in the historical imagery. If 
    the coastline has changed dramatically during the time period of interest, a
    combined mask will be best, to not erroneously mask non-water pixels. 
    
    Enter:
          var combo_water_mask = true; (mask only pixels identified as 
                                        water in historical and contemporary data)
          var combo_water_mask = false;  (mask only pixels identified as 
                                          water in historical data)
*/

var remove_water = true;
var combo_water_mask = true;

/*

2.H) Topographic Thresholds
     To threshold the data, the user has several options: 1.) The known mangrove
     extent can be used to extract the 99th percentile for slope and elevation,
     this is then used to generate a topographic mask for the input data. OR 2.) 
     The user may enter their own thresholds for both slope and elevation. NOTE: If
     the user elects to have the data automatically thresholded ('true') then the
     numbers entered here for the slope and elevation threshold will have no impact
     on the generation of the topographic mask.

     Enter:
          var mang_topo = true; (use the known mangrove extent to determine
                                 the 99th percentiles for slope and elevation, 
                                 and use these to automatically generate a 
                                 topographic mask.)
          var mang_topo = false; (use the user defined thresholds to 
                                  generate the topographic mask.)
     
     The user defined topographic thresholds: (discarded if mang_topo = true)
     
     Enter:
          var elevation = 39; (meters, meters above sea level)
          var slope = 16; (%, percent change in slope)
*/

var mang_topo = true;
var elevation = 39;
var slope = 16;

/*
2.I) Inland Fringing Mangroves
     Studies have shown that inland stands of mangroves may be found at low-lying
     elevations which are far from the coastline. For a comprehensive investigation,
     these exclaves must attempt to be captured. To do so, the ROI can be expanded 
     to 2x to account for low-lying elevations beyond the initial determination.
     
     Example: If the ROI is determined to be a 25 km buffer of the coastline (in
              Section 2), if 'var inland_mang = true', the final ROI will be expanded 
              to include all pixels between 25 and 50 km which also fall at or 
              below 5 m a.s.l.

     Enter:
          var inland_mang = true; (true, double the ROI for pixels <= 5 m a.s.l)
          var inland_mang = false; (false, retain original ROI)
*/

var inland_mang = false;

/*
2.J) Spectral Indices
     There are numerous mangrove-specific, vegetation-specific, and 
     environmental indices which can be used to aid the classification. Below is
     the included list of indices which the user may select from. The user will 
     be prompted in the console (after clicking the "Begin Workflow" button) to
     select any index which they would like to include for each dataset moving 
     forward. Note: Some indices, like the submerged mangrove recognition index 
     (SMRI) require both high and low tide imagery. This will be indicated with 
     (l) for low and (h) for high inputs.
     
     
    ############################################################################
    #    Index    #          Calculation          #        Citation            #
    ############################################################################ 
    #                                                                          #
    #   SR('RVI')   = NIR/Red                            Jordan 1969           #
    #                                                                          #
    #   NDVI        = (NIR-Red)/(NIR+Red)                Tarpley et al. 1984   #
    #                                                                          #
    #   NDWI        = (Green-NIR)/(Green+NIR)            Gao 1996              # 
    #                                                                          #
    #   MNDWI       = (Green-SWIR1)/(Green+SWIR1)        Xu 2006               #
    #                                                                          #
    #   CMRI        = NDVI-NDWI                          Gupta et al. 2018     #
    #                                                                          #
    #   MMRI        = (MNDWI-NDVI)/(MNDWI+NDVI)          Diniz et al. 2018     #
    #                                                                          #
    #   SAVI        = 1.5*(NIR-Red)/(NIR+Red+0.5)        Huete 1988            #
    #                                                                          #
    #   OSAVI       = (NIR-Red)/(NIR+Red+0.16)           Rondeaux et al. 1996  #
    #                                                                          #
    #   EVI         = 2.5*((NIR–red)/                    Huete et al. 1999     #
    #                       (NIR+6*Red–7.5*Blue+1))                            #
    #                                                                          #
    #   MRI         = |GVI(l) – GVI(h)|*GVI(l)*         Zhang and Tian 2013    #
    #                                 (WI(l)+WI(h))                            #
    #                                                                          #
    #   SMRI        = (NDVI(l)-NDVI(h))*                Xia et al. 2018        #
    #                       ((NIR(l)-NIR(h))/(NIR(h))                          # 
    #                                                                          #
    #   LWSI        = (NIR- SWIR1)/(NIR+ SWIR1)       Chandrasekar et al. 2010 # 
    #                                                                          #
    #   NDTI        = (MIR-SWIR2)/(MIR+SWIR2)         Van Deventer et al. 1997 #
    #                                                                          #
    ############################################################################
    
    
    
    ****************************************************************************
    **********************         Click 'Run' Now        **********************
    ****************************************************************************
    
    ** This line marks the end of the user-defined inputs and variables. **
    
    What follows is the bulk of the script for module 1 - below this line 
    the user does not need to further change anything. Comments are 
    provided for each section/step below so the user can understand how
    the script actually works. All further user action occurs in the ‘Console'.
    
    NOTE:
      -Once the 'Workflow' has begun, the user will be walked through several
       interative steps.
      -Several intermediary outputs will be generated from GEM Module 1. 
       These outputs MUST be exported to the user's GEE 'Assets'
      -Work through Module 1 completely and ensure all exports have successfully
       been added to the user 'Assets' folder before proceeding to GEM Module 2
      -Do not change the name of the exports unless you are an advanced GIS user
      
                *** DO NOT EDIT ANYTHING BELOW THIS LINE ***
*/

























////////////////////////////////////////////////////////////////////////////////
// Required Modules

// This is where the required functions are called into the script
var known_ext =  require('users/yanchojo/GEM_LS9_colors/:modules/known_mangroves');
var coastline =  require('users/yanchojo/GEM_LS9_colors/:modules/coastline');
var topography =  require('users/yanchojo/GEM_LS9_colors/:modules/topography');
var mangrove_buff = require('users/yanchojo/GEM_LS9_colors/:modules/mangrove_buff');
var water = require('users/yanchojo/GEM_LS9_colors/:modules/water_mask');
var fringe = require('users/yanchojo/GEM_LS9_colors/:modules/fringe_mang');
var imagery = require('users/courtlandfowler/gemv2:imagery');
var indx_mod = require('users/courtlandfowler/gemv2:indices');


/////////////////////////
// Section 1, Step 2.J //
/////////////////////////
// This code sets up the user to select the indices that they would like to add.
// All of the selection is done in the console through a series of checkboxes
// which add/remove each index.

var allMonths = ui.data.ActiveList(['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']);

function selectMonths(timeframeStr, twelveZeros) {
  print('\nSelect the ' + timeframeStr + ' months of interest:');
  allMonths.forEach(function(month) {
    var box = ui.Checkbox(month, false);
    box.onChange(function(checked) {
      var i = allMonths.getJsArray().indexOf(month);
      if (checked === true) {
        twelveZeros[i] = i + 1;
      } else {
        twelveZeros[i] = 0;
      }
    }); 
    print(box);
  });
}

function filterMonths(months) {
  var filtered = [];
  for (var i = 0; i < months.length; i++) {
    var month = months[i];
    if (month > 0) {
      filtered.push(month);
    }
  }
  return filtered;
}

var cmonths = [0,0,0,0,0,0,0,0,0,0,0,0];
var hmonths = [0,0,0,0,0,0,0,0,0,0,0,0];

var months_step_button = ui.Button('Select Months');
months_step_button.onClick(function() {
  print('The time of year selected should focus on a few key\n' +
  'environmental variables that will impact the imagery.\n\n' +
  'These include:\n' +
      '1.) The contrast of mangrove vegetation from\n  surrounding land cover.\n' +
      '2.) The persistence of clouds in the region\n  (e.g. dry or wet seasons).\n\n' +
     'Region-specific knowledge of the study area should\n' +
     'be used to support the decision around the selection\n  ' +
     'of seasonal month range.\n\n' + 
     'If the user needs to learn more about the seasonality\n' + 
     'of the study area they may refer to the RiceAtlas\n' +
     'database as one source of seasonality info\n' +
     '(Laborte et al, 2017).\n' +
     '(https://www.nature.com/articles/sdata201774).\n');
  selectMonths("Contemporary", cmonths);
  selectMonths("Historical", hmonths);

var step_1_button = ui.Button('Begin Workflow');
step_1_button.onClick(function() {
  // Print step label
  print(ui.Label({value:'Module 1: Setion 1, Step 1',
                  style:{fontWeight: 'bold',
                         fontSize: '18px',
                         textAlign: 'center'}
                }));
  // Ingest the known mangrove extent
  var mang_img = known_ext.known_mang(kmx);
  
  // Print Index selection instructions
  print('Select the indices to be calculated in Section 4');
  
  // Ingest the topographic data (DSM)
  var dsm = topography.dsm_id(topo);
  
  // Create the coastline from the coarse ROI
  var coast = coastline.coast_In(cst, cst_path, coarse_roi);
  Map.centerObject(coarse_roi);
  
  // Filter month lists to remove empty values
  var contemporary_months = filterMonths(cmonths);
  var historical_months = filterMonths(hmonths);
  
  var use_s2 = imagery.should_use_s2(contemporary_start_year, contemporary_months, historical_start_year, historical_months);
  var starts = "before";
  var but = "";
  var imagery_name = "Landsat";
  var warning = "";
  if (use_s2) {
    starts = "after or during";
    if (force_landsat) {
      but = "but you have chosen to force the use of Landsat, ";
    } else {
      imagery_name = "Sentinel-2";
      warning = "\n\nSentinel-2 imagery is much larger than Landsat. If this imagery is too large, you can use the 'force_landsat' parameter to switch to Landsat imagery instead.";
    }
  }
  
  alert("Your date range starts " + starts + " 12/2018, " + but + "so the GEM will use " + imagery_name + " imagery." + warning);
  
  // Create the tidal area buffer
  var tidalArea = coast.simplify(500).buffer(tidal_zone).simplify(500);
  
  // Generate the empty index list
  var indx = ee.List([]);
  
  // List of refernce indices
  var OG_band_list = ui.data.ActiveList(['SR','NDVI','NDWI','MNDWI','CMRI','MMRI','SAVI',
  'OSAVI','EVI','MRI','SMRI','LSWI','NDTI']);
  
  // Create checkboxes 
  OG_band_list.forEach(function(x){
    var ind_box = ui.Checkbox(x, false);
    ind_box.onChange(function(checked) {
    // Add/remove the index to the list
    if (checked === true){indx = indx.add(x);
    } else {indx = indx.remove(x);}}); 
    print(ind_box);
  });
  
  // Print instructions
  print('Print the index list to review indices selected');
  
  // Print index list button
  var button = ui.Button({
  label: 'Print Index List',
  onClick: function() {
    print('Index List', indx.distinct());
    return ee.List(indx.distinct());
    }
  });
  print(button);
  

  ///////////////
  // Section 2 //
  ///////////////
  // Here the user will determine the shoreline buffer distance to be used in 
  // the workflow, which is ultimately set-up to be the first stage of the final 
  // ROI. A known mangrove extent is buffered at multiple distances from the  
  // input coastline to calculate the area of mangroves included at various 
  // buffer extents. The user then selects the ROI buffer distance from a 
  // drop-down menu.
  
  var step_2_button = ui.Button('Section 2: Determine ROI');
  step_2_button.onClick(function(){
    print(ui.Label({value:'Module 1: Section 2',
                  style:{fontWeight: 'bold',
                         fontSize: '18px',
                         textAlign: 'center'}
                }));
    print('Use the calculated known mangrove extent areas, displayed'+
          '\nbelow in table and graphical format, to elect a region of'+
          '\ninterest (ROI) buffer distance that encompasses, at a '+
          '\nminimum, all of the currently known mangroves.');
    
    var indx_list = indx;

    // Buffer the known mangrove extent using the coastline
    var mang_buff_img = mangrove_buff.mang_buff(coast, mang_img, coarse_roi, exclusion_geometries);

    // Create a table of the mangrove area
    var buffer_table = mangrove_buff.areaTable(mang_buff_img, coarse_roi, exclusion_geometries);

    // Graphically display mangrove area table
    var buffer_chart = mangrove_buff.areaChart(buffer_table); 
    
    // Add the mangrove buffer layers to the map
    Map.addLayer(mang_buff_img.select('35'), {palette: ['CC0000']}, '35km buffer');
    Map.addLayer(mang_buff_img.select('30'), {palette: ['FF780A']}, '30km buffer');
    Map.addLayer(mang_buff_img.select('25'), {palette: ['FC9F0D']}, '25km buffer');
    Map.addLayer(mang_buff_img.select('20'), {palette: ['F9CB24']}, '20km buffer');
    Map.addLayer(mang_buff_img.select('15'), {palette: ['74B800']}, '15km buffer');
    Map.addLayer(mang_buff_img.select('10'), {palette: ['3E8F00']}, '10km buffer');
    Map.addLayer(mang_buff_img.select('05'), {palette: ['006600']}, '5km buffer');
    // Print the chart and table to the console
    print("Mangrove Area by Buffer", buffer_table);
    print(buffer_chart);
    // Have the user set the buffer distance and create ROI
    var ROI = ee.Geometry(coast);
    var buff_dist = ee.Number(0);
    // List of buffers to choose from
    var buffers = {
     '1 km': [1000], '2.5 km': [2500], '5 km': [5000], '7.5 km': [7500],
     '10 km': [10000], '12.5 km': [12500], '15 km': [15000], '17.5 km': [17500],
     '20 km': [20000], '22.5 km': [22500], '25 km': [25000], '27.5 km': [27500],
     '30 km': [30000], '32.5 km': [32500], '35 km': [35000], '37.5 km': [37500],
     '40 km': [40000], '50 km': [50000], '60 km': [60000], '75 km': [75000],
    };
    // Create drop-down menu to select ROI buffer
    var select_ROI = ui.Select({
      items: Object.keys(buffers),
      onChange: function(key) {
      ROI = coast.buffer(buffers[key][0]).intersection(coarse_roi);
      buff_dist = ee.Number(buffers[key][0]);
      }
    });

    // Set a place holder for the drop down
    select_ROI.setPlaceholder('Choose an ROI Buffer...');
    // Add drop down to console
    print(select_ROI);
    
    ///////////////
    // Section 3 //
    ///////////////
    // The variables from Setion 1 are used to generate the image composites
    // which will be used through out the rest of the GEM. image 
    // composites will be added to the GUI map viewer.
    
    // Prepare the imagery
    var step_3_button = ui.Button('Section 3: Prepare Imagery for Processing');
    step_3_button.onClick(function(){
      print(ui.Label({value:'Module 1: Section 3',
                  style:{fontWeight: 'bold',
                         fontSize: '18px',
                         textAlign: 'center'}
                }));
      print('When the imagery has been prepared, '+
            '\nbuttons will appear to display the imagery;'+
            '\nindicating to add either the contemporary'+
            '\nand/or historical imagery to the map.'+
            '\nDo not proceed before these buttons populate'+
            '\nthe console. Click the buttons to view the '+
            '\nimagery.');
      Map.clear(); // Reset the map
      for (var i = 0; i < exclusion_geometries.length; i++) {
        ROI = ROI.difference(exclusion_geometries[i]);
      }
      Map.addLayer(ROI, {color: '1E266F'}, "ROI"); // Add ROI to map
      
      // Clip the known mangrove extent
      var kn_mang_ext = mang_img.clip(ROI);
      var false_colour_bands = ['B4','B5','B3'];
      
      // Create hist./cont. image collections
      var force_ls = force_landsat || !imagery.should_use_s2(contemporary_start_year, contemporary_months, historical_start_year, historical_months);
      var cont_result = imagery.get_imagery(force_ls, ls_7_in, ROI, cloud_cover, contemporary_start_year, contemporary_end_year, contemporary_months, cloud_mask, tidalArea);
      var hist_result = imagery.get_imagery(force_ls, ls_7_in, ROI, cloud_cover, historical_start_year, historical_end_year, historical_months, cloud_mask, tidalArea);
      var cont_imagery = cont_result[0];
      var hist_imagery = hist_result[0];
      var imagery_scale = cont_result[1];
      
      if (force_ls) {
        print("Using Landsat at " + imagery_scale + "m scale");
      } else {
        print("Using Sentinel-2 at " + imagery_scale + "m scale");
      }

      print('No. Contemporary Images: ' + ee.String(ee.ImageCollection(cont_imagery).size()).getInfo());
      print('No. Historical Images: ' + ee.String(ee.ImageCollection(hist_imagery).size()).getInfo());
      
      var export_max_pixels = 1e13;
      
      // Build the contemporary BAP composites
      var Chot = ee.ImageCollection(cont_imagery).qualityMosaic('MNDWI').clip(ROI);
      var Clot = ee.ImageCollection(cont_imagery).qualityMosaic('inv_MNDWI').clip(ROI);
      var chot_vis = Chot;
      var clot_vis = Clot;
      
      // Add the contemporary imagery once it has finished processing 
      clot_vis.evaluate(function(){
        var add_c_imagery = ui.Button('Add Contemporary Imagery');
        add_c_imagery.onClick(function(){
        // Add to Map
          var vis = {bands: false_colour_bands, min: 0, max: 0.27};
          Map.addLayer(chot_vis, vis, 'Contemporary High Tide');
          Map.addLayer(clot_vis, vis, 'Contemporary Low Tide');
        });
        print(add_c_imagery);
      });
      
      // Build the historical BAP composites
      var Hhot = ee.ImageCollection(hist_imagery).qualityMosaic(imagery.mod_water_index).clip(ROI);
      var Hlot = ee.ImageCollection(hist_imagery).qualityMosaic(imagery.inverse_mod_water_index).clip(ROI);
      var hhot_vis = Hhot;
      var hlot_vis = Hlot;

      // Add the historical imagery once it has finished processing
      hlot_vis.evaluate(function(result){
        var add_h_imagery = ui.Button('Add Historical Imagery');
        add_h_imagery.onClick(function(){
          // Add to Map
          var vis = {bands: false_colour_bands, min: 0, max: 0.27};
          Map.addLayer(hhot_vis, vis, 'Historical High Tide');
          Map.addLayer(hlot_vis, vis, 'Historical Low Tide');
        });
        print(add_h_imagery);
      });
      
      Chot = Chot.select('B1','B2','B3','B4','B5','B7');
      Clot = Clot.select('B1','B2','B3','B4','B5','B7');
      Hhot = Hhot.select('B1','B2','B3','B4','B5','B7');
      Hlot = Hlot.select('B1','B2','B3','B4','B5','B7');
      
      ///////////////
      // Section 4 //
      ///////////////
      // The indices variables selected in Section 1 are calculated. Once 
      // calculated, the user will be prompted to export the imagery
      // to their GEE asset folder. 
      
      // Calculation of the spectral indices
      var step_4_button = ui.Button('Section 4: Calculate the Spectral Indices');
      step_4_button.onClick(function(){
        print(ui.Label({value:'Module 1: Section 4',
                  style:{fontWeight: 'bold',
                         fontSize: '18px',
                         textAlign: 'center'}
                }));
        print('When the indices have been calculated'+
            '\nthe imagery and indices will be prepared for export.'+
            '\nThen, an alert will appear in the console when the '+
            '\nindices are calculated. The task tab will turn yellow.'+
            '\n'+
            '\nOnce the task tab turns yellow, click the tab and click'+
            '\non Run for each item that has populated the Tasks tab.'+
            '\nBe sure that the export is directed to your asset folder.');

        // Add single-image indices     
        var Chot1 = ee.Image(indx_mod.addIndex_simple(indx_list, Chot));
        var Clot1 = ee.Image(indx_mod.addIndex_simple(indx_list, Clot));
        var Hhot1 = ee.Image(indx_mod.addIndex_simple(indx_list, Hhot));
        var Hlot1 = ee.Image(indx_mod.addIndex_simple(indx_list, Hlot));
        
        // Add SMRI if in list
        var Chot2 = ee.Algorithms.If(indx_list.contains('SMRI'), 
        ee.Image(Chot1).addBands(indx_mod.SMRI(Chot1, Clot1)),  ee.Image(Chot1));
        var Clot2 = ee.Algorithms.If(indx_list.contains('SMRI'), 
        ee.Image(Clot1).addBands(indx_mod.SMRI(Chot1, Clot1)),  ee.Image(Clot1));
        var Hhot2 = ee.Algorithms.If(indx_list.contains('SMRI'), 
        ee.Image(Hhot1).addBands(indx_mod.SMRI(Hhot1, Hlot1)),  ee.Image(Hhot1));
        var Hlot2 = ee.Algorithms.If(indx_list.contains('SMRI'), 
        ee.Image(Hlot1).addBands(indx_mod.SMRI(Hhot1, Hlot1)),  ee.Image(Hlot1));
        
        // Add MRI if in list
        var Chot3 = ee.Algorithms.If(indx_list.contains('MRI'), 
        ee.Image(Chot2).addBands(indx_mod.MRI(Chot2, Clot2)),  ee.Image(Chot2));
        var Clot3 = ee.Algorithms.If(indx_list.contains('MRI'), 
        ee.Image(Clot2).addBands(indx_mod.MRI(Chot2, Clot2)),  ee.Image(Clot2));
        var Hhot3 = ee.Algorithms.If(indx_list.contains('MRI'), 
        ee.Image(Hhot2).addBands(indx_mod.MRI(Hhot2, Hlot2)),  ee.Image(Hhot2));
        var Hlot3 = ee.Algorithms.If(indx_list.contains('MRI'), 
        ee.Image(Hlot2).addBands(indx_mod.MRI(Hhot2, Hlot2)),  ee.Image(Hlot2));
        
        // Export Imagery with indices as bands
        Chot3 = ee.Image(Chot3).float();
        Clot3 = ee.Image(Clot3).float();
        Hhot3 = ee.Image(Hhot3).float();
        Hlot3 = ee.Image(Hlot3).float();
        var test = ee.Image(Hlot3).addBands(ee.Image.constant(2));              
       
        // Export Imagery with indices as bands
        Export.image.toAsset({
            image: ee.Image(Chot3),
            description: 'HOT_Img_contemporary',
            region: ROI,
            scale: imagery_scale,
            maxPixels: export_max_pixels
          });

        Export.image.toAsset({
            image: ee.Image(Clot3),
            description: 'LOT_Img_contemporary',
            region: ROI,
            scale: imagery_scale,
            maxPixels: export_max_pixels
          });

        Export.image.toAsset({
            image: ee.Image(Hhot3),
            description: 'HOT_Img_historical',
            region: ROI,
            scale: imagery_scale,
            maxPixels: export_max_pixels
          });

        Export.image.toAsset({
            image: ee.Image(Hlot3),
            description: 'LOT_Img_historical',
            region: ROI,
            scale: imagery_scale,
            maxPixels: export_max_pixels
          });

        ///////////////
        // Section 5 //
        ///////////////
        // Section 5 will create the masks, and ultimately the final mask
        // for the classification(s). The exports will automatically populate  
        // the task tab. Just like the imagery it should be exported to each 
        // user's asset folder.
        
        // section 5 button
        var step_5_button = ui.Button('Section 5: Prepare Image Mask');
        step_5_button.onClick(function(){
          print(ui.Label({value:'Module 1: Section 5',
                  style:{fontWeight: 'bold',
                         fontSize: '18px',
                         textAlign: 'center'}
                }));
          print('When the final mask has been prepared the task tab'+
              '\nwill turn yellow, prompting for export. The final mask'+
              '\nand the other intermediary outputs can be viewed in the'+
              '\npanel by clicking on the corresponding button.'+
              '\n'+
              '\nOnce all the of intermediary outputs have begun to export'+
              '\nGEM Module 1 is complete. Proceed to GEM Module 2'+
              '\nafter all outputs have successfully been exported and'+
              '\nadded to the asset GEE asset folder.');
        
          // Bring in topo data and create the mask
          var dsm = topography.dsm_id(topo, topo_path);
          var topo_mask = topography.topo_mask_func(dsm, kn_mang_ext, 
                                    mang_topo, elevation, slope);
          
          // Use low tide images to create water mask
          var clot_water = cont_imagery.filter(ee.Filter.gte(imagery.mod_water_index, min_avg));
          print('No. Contemporary Low-Tide Images for Water Mask: ' + ee.String(clot_water.size()).getInfo());
          clot_water = clot_water.qualityMosaic(imagery.inverse_mod_water_index).clip(ROI);
          var hlot_water = hist_imagery.filter(ee.Filter.gte(imagery.mod_water_index, min_avg));
          print('No. Historical Low-Tide Images for Water Mask: ' + ee.String(hlot_water.size()).getInfo());
          hlot_water = hlot_water.qualityMosaic(imagery.inverse_mod_water_index).clip(ROI);
          
          print("If your water mask and final mask are incomplete,\n"+
            "review above the number of contemporary and historical\n"+
            "low-tide images available for the water mask.\n\n"+
            "There must be enough images to cover your entire ROI -\n"+
            "if not enough, widen the months and/or years windows\n"+
            "to filter in more imagery.");
          
          if(remove_water === true){
              var waterMask = water.water_mask(hlot_water, clot_water, combo_water_mask);
            }else{
              var waterMask = ee.Image(1);
            }
          // Combine the topo and water masks
          var combo_masked = waterMask.multiply(topo_mask).eq(1);
          
          // Create the fringe mangrove mask
          var fringe_mask = fringe.fringMangrove(dsm, buff_dist, ROI);
          
          // Add buttons to view the mask outputs
          var topo_mask_butt = ui.Button('View Topo Mask?');
              topo_mask_butt.onClick(function(){
                Map.addLayer(ee.Image(topo_mask.clip(ROI)), {}, 'Topographic Mask');});
          var water_mask_butt = ui.Button('View water Mask?');
              water_mask_butt.onClick(function(){
                Map.addLayer(ee.Image(waterMask), {}, 'Water Mask');});
          var combo_mask_butt = ui.Button('View combo Mask?');
              combo_mask_butt.onClick(function(){
                Map.addLayer(ee.Image(combo_masked), {}, 'Combine Mask');});
          
          // Fringe mangrove addition to mask or not
          var in_t = function(combo_masked, fringe_mask){
            var final_mask = ee.Image(combo_masked).add(fringe_mask);
            return final_mask;
          };
          var in_f = function(combo_masked){
            var final_mask = combo_masked;
            return final_mask;
          };          
          
          // Final Mask creation
          if(inland_mang === true){var final_mask =  in_t(combo_masked, fringe_mask);
                                       ROI = ROI.buffer(buff_dist);}
                              else {var final_mask =  in_f(combo_masked);}

          // Export final mask
          Export.image.toAsset({
              image: final_mask,
              description: 'Final_mask',
              region: ROI,
              scale: imagery_scale,
              maxPixels: export_max_pixels
            });
            
          // Prepare final ROI for export
          var ROI_out = ee.FeatureCollection(ee.Feature(ROI, {name: 'ROI'}));
          // Export final ROI
          Export.table.toAsset({
            collection: ROI_out,
            description: "ROI",
            assetId: 'ROI'
            });
          
          // Create Final Mask Button
          var final_mask_butt = ui.Button('View final Mask?');
              final_mask_butt.onClick(function(){Map.addLayer(ee.Image(final_mask).clip(ROI), {}, 'Final Mask');});
              
          // Create Panel
          var mask_panel = ui.Panel({
            layout: ui.Panel.Layout.flow('vertical'),
            style: {width: '300px'}
            });
            
          // Add buttons to the panel
          mask_panel.add(topo_mask_butt);
          mask_panel.add(water_mask_butt);
          mask_panel.add(combo_mask_butt);
          mask_panel.add(final_mask_butt);
          
          // Add the panel to the map
          ui.root.add(mask_panel);

        });
        test.evaluate(function(){ // Safety to not proceed until ready
          print('ALERT: Spectral Indices Successfully Calculated');
          print(step_5_button);});
      });
      print(step_4_button);
    });
    print(step_3_button);
  });
  print(step_2_button);
});
print(step_1_button);
});
alert('First we will select the months of interest\n(for Contemporary & Historical year ranges)');
print(months_step_button);


/*
At the end of the workflow, the user should have started exporting:
      1) HOT contemporary composite (HOT_Img_contemporary)
      2) LOT contemporary composite (LOT_Img_contemporary)
      3) HOT historical composite (HOT_Img_historical)
      4) LOT historical composite (LOT_Img_historical)
      5) Finalized ROI (ROI) 
      6) Finalized mask (final_mask)
*/
////////////////////////////////////////////////////////////////////////////////  
